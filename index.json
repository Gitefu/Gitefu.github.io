[{"categories":["FPGA"],"contents":"前回 ドキュメントを読んだ．\n前回の記事：Alveo U250でXPM_MEMORY_SPRAMを使いたい(1)\ngithubのソースを使ってみる githubでXPM_MEMORY_SPRAMを使っているモジュールを見つけたので，使ってみる．\nGithub:pulp-platform/tech_cells_generic\n(https://github.com/pulp-platform/tech_cells_generic)\ngithubの該当のソースコードを書き換え tech_cells_generic/src/fpga/tc_sram_xilinx.svを使ってみようと思う． ただこのままでは初期化用のファイルを指定できない． 設定できるようにしよう．\nparameterInitFileで初期化ファイルを指定するようにする 次のように書き換える． 32 33 34 parameter type data_t = logic [DataWidth-1:0], parameter type be_t = logic [BeWidth-1:0], parameter InitFile = \u0026#34;none\u0026#34; // 追加：初期化ファイル 各モジュールのMEMORY_INIT_FILEにInitFileを割り当て Single Port RAMのモジュール まずはxpm_memory_spram: Single Port RAM側を2箇所80,81行目を編集． 73 74 75 76 77 78 79 80 81 82 // xpm_memory_spram: Single Port RAM // XilinxParameterizedMacro, version 2018.1 xpm_memory_spram#( .ADDR_WIDTH_A ( AddrWidth ), // DECIMAL .AUTO_SLEEP_TIME ( 0 ), // DECIMAL .BYTE_WRITE_WIDTH_A ( ByteWidth ), // DECIMAL .ECC_MODE ( \u0026#34;no_ecc\u0026#34; ), // String .MEMORY_INIT_FILE ( InitFile ), // 書き換え：String .MEMORY_INIT_PARAM ( \u0026#34;\u0026#34; ), // 書き換え：String .MEMORY_OPTIMIZATION ( \u0026#34;true\u0026#34; ), // String True Dual Port RAMのモジュール 次にxpm_memory_tdpram: True Dual Port RAM側を2箇所119,120行目を編集． 109 110 111 112 113 114 115 116 117 118 119 120 121 // xpm_memory_tdpram: True Dual Port RAM // XilinxParameterizedMacro, version 2018.1 xpm_memory_tdpram#( .ADDR_WIDTH_A ( AddrWidth ), // DECIMAL .ADDR_WIDTH_B ( AddrWidth ), // DECIMAL .AUTO_SLEEP_TIME ( 0 ), // DECIMAL .BYTE_WRITE_WIDTH_A ( ByteWidth ), // DECIMAL .BYTE_WRITE_WIDTH_B ( ByteWidth ), // DECIMAL .CLOCKING_MODE ( \u0026#34;common_clock\u0026#34; ), // String .ECC_MODE ( \u0026#34;no_ecc\u0026#34; ), // String .MEMORY_INIT_FILE ( InitFile ), // 書き換え：String .MEMORY_INIT_PARAM ( \u0026#34;\u0026#34; ), // 書き換え：String .MEMORY_OPTIMIZATION ( \u0026#34;true\u0026#34; ), // String これでよし．\nテストベンチファイル作成 テストベンチを作る． まあ細かい動作確認はするつもりなくて，アドレスから正しい値を読めるかなあって確認だけ． それってテストベンチか？\nとりあえず./test/tb_tc_sram_origin.svを作成．\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 `timescale 1ns / 1ps // ----- 定数たち ----- `define DATA_WIDTH 128 `define ADDR_WIDTH 10 // -------------------- module tb_tc_sram_origin; // ----- クロックの動作 ----- logic clk_i; initial begin clk_i \u0026lt;= 1\u0026#39;b0; #2; forever begin #1; clk_i \u0026lt;= (clk_i==1\u0026#39;b1)?1\u0026#39;b0:1\u0026#39;b1; end end // -------------------- // ----- メモリの動作 ----- // // モジュールの宣言 logic rst_ni; logic req_i; logic we_i; logic [ `ADDR_WIDTH -1:0] addr_i; logic [ `DATA_WIDTH -1:0] wdata_i; logic [ (`DATA_WIDTH/8) -1:0] be_i; logic [ `DATA_WIDTH -1:0] rdata_o; // // モジュールの宣言 tc_sram #( .NumWords ( 2**(`ADDR_WIDTH) ), .NumPorts ( 1 ), .DataWidth ( `DATA_WIDTH ), .SimInit ( \u0026#34;random\u0026#34; ), .InitFile ( \u0026#34;hello_world.mem\u0026#34; ) ) ram_0 ( .clk_i ( clk_i ), .rst_ni ( rst_ni ), .req_i ( req_i ), .we_i ( we_i ), .addr_i ( 10\u0026#39;h0 + addr_i[($clog2(2**10)+$clog2(`DATA_WIDTH/8)) -1:$clog2(`DATA_WIDTH/8)] ), .wdata_i( wdata_i ), .be_i ( be_i ), .rdata_o( rdata_o ) ); // // 各信号の制御 initial begin $dumpfile( \u0026#34;result.vcd\u0026#34; ); $dumpvars( 0, ram_0 ); #10; //全信号の初期化 rst_ni \u0026lt;= 1\u0026#39;b1; req_i \u0026lt;= 1\u0026#39;b0; we_i \u0026lt;= 1\u0026#39;b0; addr_i \u0026lt;= 10\u0026#39;h000; wdata_i \u0026lt;= 128\u0026#39;h00000000000000000000000000000000; be_i \u0026lt;= 16\u0026#39;hFFFF; #10; // リセット:ON rst_ni \u0026lt;= 1\u0026#39;b0; #10; // リセット:OFF rst_ni \u0026lt;= 1\u0026#39;b1; #10; // 0x0000から値を読み取り addr_i \u0026lt;= 10\u0026#39;h000; req_i \u0026lt;= 1\u0026#39;b1; #10; // req_iを下げる req_i \u0026lt;= 1\u0026#39;b0; #10; // 0x0010から値を読み取り addr_i \u0026lt;= 10\u0026#39;h010; req_i \u0026lt;= 1\u0026#39;b1; #10; // req_iを下げる req_i \u0026lt;= 1\u0026#39;b0; #10; // おしまい $finish; end endmodule テストベンチの実行 当然だけど，iverilogコマンドでは動作確認できない．．．まあVivadoでやりましょう．\n次のtclファイルをtcl/test.tclって名前で作りましょ．\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # -----変数------------- set outputDir \u0026#34;./output\u0026#34; ; # プロジェクトのディレクトリを設定 set projectName \u0026#34;vivado_prj\u0026#34; ; # プロジェクト名を設定 set device_name \u0026#34;xilinx.com:au250:part0:1.3\u0026#34; ; # デバイス名を設定 set part_name \u0026#34;xcu250-figd2104-2L-e\u0026#34; ; # fpgaチップ名を設定 # -----前回の実行結果を削除------------- file delete -force $outputDir file mkdir $outputDir # -----プロジェクトの作成------------- create_project -force $projectName $outputDir -part $part_name ;# プロジェクトファイル作成 set_property board_part $device_name [current_project] ;# FPGA update_ip_catalog ; # -----シミュレーション時間の制限を削除------------- set_property -name {xsim.simulate.runtime} -value {-all} -objects [get_filesets sim_1] # -----ソースを追加------------- add_file test/tb_tc_sram_origin.sv add_file src/fpga/tc_sram_xilinx.sv add_file test/hello_world.mem # -----トップモジュールを設定------------- set_property top tb_tc_sram_origin [current_fileset] set_property top tb_tc_sram_origin [get_filesets sim_1] # -----シミュレーション実行------------- update_compile_order -fileset sources_1 launch_simulation source $outputDir/$projectName.sim/sim_1/behav/xsim/tb_tc_sram_origin.tcl # ----プロジェクトを閉じる------------- close_project そのあと以下のコマンドを実行する． 0 vivado -mode batch -source test/test.tcl 最後に以下のコマンドを実行して作成したvcdファイルを確認． 0 gtkwave ./output/vivado_prj.sim/sim_1/behav/xsim/result.vcd 実行結果はこんな感じ 読めてそう．色々使えることがあるところがあると嬉しいな．\n","permalink":"https://gitefu.github.io/blog/2023/alveou250/xpm_memory_spram/post2/","tags":["FPGA","Alveo"],"title":"Alveo U250でXPM_MEMORY_SPRAMを使いたい(2)"},{"categories":["FPGA"],"contents":"Alveo U250でXPM_MEMORY_SPRAMを使いたい ちょっとAlveo U250でRAMを指定のファイルで初期化することにした． Alveo U250はultrascale+をベースに云々ってサイトに書いてあるので，XPM_MEMORY_SPRAMが使えそう． ECC周りは不要なので，まあ無視します． それ以外の部分ちょこちょこ使ってみましょう．\n公式ドキュメントを読む UltraScale Architecture Libraries Guide (UG974):XPM_MEMORY_SPRAM\nこの記事ではまずドキュメントの軽い日本語化を目指すかなあ．\nXPM_MEMORY_SPRAMとは Parameterized Macro: Single Port RAM\nって書かれているわね．まあただのSingle PortのRAMでしょって思っている．\nFamilies: UltraScale, UltraScale+\nなるほど？ということは，それなりのサイズのものにしか使えないのかな？\nreadについて 全部クロック同期ですね，当たり前だけど． addraにアドレスを送るとdoutaに値が返ってくる．このタイミングはenaで告知されるのと，遅延量はREAD_LATENCY_Aに依存するらしい．\nwriteについて weaを立てると，書き込み．enaも立てましょう． addraにアドレスを送って，データはdinaに送る．\nこの時のdoutaはWRITE_MODE_Aってパラメータで振る舞いを変えられるらしい．\nリセットについて rstaを立てると，同期的にREAD_RESET_VALUE_Aで設定した値になるらしい．ちなみにこれはREAD_LATENCY_Aに依存しない．\n出力維持 regceaを立ててrstaを下げると，最後の出力をそのままし続けてくれるっぽい．\nサイズについて MEMORY INIT PARAMを使う時，メモリサイズは最大でも4K[bits]らしい． MEMORY INIT PARAMについては，説明読んでもよくわかっていないので，必要になるまで一旦スルー．\nその他 Memory initialization with Asymmetric Byte Write Enableはサポートしていないとのこと． Asymmetric Byte Write Enable自体を知らないので，よくわからん．Asymmetricは非対称．うーんどういうこと？\nMEMORY_INIT_FILE 初期化するときに，hoge.memみたいなやつで初期化したいので，調べる．\n拡張子 ***.memでないと怒られる．たとえばhello.mifだと怒られる．\nmemファイルの書き方 ASCIIで16新数表記．幅はメモリに合わせればよさそう． あと当然だけど，Vivado projectにmemファイルを入れましょう．\nMEMORY_INIT_PARAMについて MEMORY_INIT_PARAMも存在するが，これは\u0026quot;\u0026quot;にしないといかん． MEMORY_INIT_PARAMが優先されるっぽいね．\n次の記事 次の記事：Alveo U250でXPM_MEMORY_SPRAMを使いたい(2)\n","permalink":"https://gitefu.github.io/blog/2023/alveou250/xpm_memory_spram/post1/","tags":["FPGA","Alveo"],"title":"Alveo U250でXPM_MEMORY_SPRAMを使いたい(1)"},{"categories":["FPGA"],"contents":"内容について 2023.03.24時点の内容です．\n公式ドキュメントに書いてあったので，メモしただけ．\nVivado Design Suite ユーザー ガイド: インプリメンテーション (UG904):Vivado ツールでのマルチスレッド\nこのサイトを以下では公式ドキュメントと呼称しますわね．\n書いてあった内容 最大8スレッド 公式ドキュメントから引用するとこんな感じ．\nマルチプロセッサ システムでは、Vivado ツールで DRC レポート、スタティック タイミング解析、配置、配線などのプロセスを高速化するためマルチスレッドが使用されます。同時に使用される最大スレッド数は、プロセッサの数、タスクによって異なります。タスクによって使用される最大スレッド数は、次のとおりです。\nDRC レポート: 8 スタティック タイミング解析: 8 配置: 8 配線: 8 物理最適化: 8 つまり，10コア20スレッドのプロセッサ使っても8が限界ってことかあ．\nちなみに 1 set_param general.maxThreads 8 最大値を決められる．これやらないと怒られる時なんてそうそうないけどね．\nWindowsは2スレッドが限界 公式ドキュメントには以下のように書いてある．\n同時に実行可能なスレッドのデフォルト最大数は、OS によって異なります。Windows システムでは 2 で、Linux システムではデフォルトは 8 です。\nマジ？？？という気持ち． うーん，FPGAの開発環境を整えるときはLinuxがいいわね． てかmacOSの対応してほしい\nだけど，重要なのは公式ドキュメントの以下の文．\n同時に使用可能なスレッド数は、次の最小の値になります。\nプロセッサの最大数 タスクの制限スレッド数 一般制限スレッド数 ということは，windows環境でgeneral.maxThreadsを8にしても，使われるスレッドは2つってことだね．\nまとめ とりあえず8スレッドって宣言しときゃあ，勝手に最大値に設定してくれるってことだな！ヨシ！\n以上．\n","permalink":"https://gitefu.github.io/blog/2023/vivado/aboutmaxthreads/post/","tags":["FPGA","Vivado"],"title":"Vivadoツールでのマルチスレッドの話"},{"categories":["FPGA"],"contents":"Virtual I/OをUARTの代わりに なんかAlveoU250でUARTが使えない うーん．なぜかAlveo U250でUARTが使えない．\nただ文字を表示したいだけだし，UARTモジュールを実装してみたんだけど，動かなかった． なんでや！と思ってXDCファイルを更新したり，ドライバ再インスコしたり，再起動したり，色々したんだけど．．． 困るのよねえ．何かtipsあればTwitter(@tnk_make)で教えてください．．．\n代わりにVirtual I/Oを使う マジで嫌々，仕方無〜〜〜くUARTの代わりにVirtual IOで文字列の確認できないかなあと考えた． こんなクソ発想せずにUARTしたいんだが，，，．\nVirtual I/O ってなあに XilinxのVirtual Input/Output (VIO)についてのドキュメントは こちら(https://docs.xilinx.com/v/u/en-US/pg159-vio)．\nフレームレートに関して，1msとか指定できるけど，なんかよくエラー吐くので使わないようにしよう． まあ100ms程度であれば問題ないかな．うーん，10Hzか．なんだこれ．\n動作確認 ひとまずこんな予定\nArty S7で動かしてみる Alveo U250で動かしてみる まずは個人の持っているArty S7で正しく動くことを確認する．\nその上でもしAlveoU250でうまく動かなければ，多分Clocking Wizardの使い方を間違えている．\nAlveoU250で動いたら，まあOK．\n設計 設計はこんな感じ．AlveoではこのCLK100MHzにClocking Wizardを接続しようかな．\nディレクトリ構成 . ├── consts │ ├── Arty-S7-50-Master.xdc │ └── alveo-u250-xdc.xdc ├── rtls │ ├── clock_gen_for_vio.sv │ ├── dammy_rtl.sv │ ├── top_usb_uart_tx.sv │ ├── top_usb_uart_tx_with_clkwiz.sv │ └── tx_fifo.sv └── tcl ├── build.tcl ├── define.tcl ├── show_vio.tcl └── sources ├── make_clocking_wizard_design.tcl └── make_vio_design.tcl RTL ./rtlsの中身をそれぞれ解説しますわね．\nClocking Wizardなしverのトップモジュール (top_usb_uart_tx.sv) Artyならこれを使う．\n信号名 bit幅[bit] 役割 CLK100MHZ 1 100MHzのクロック信号 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 module top_usb_uart_tx ( input logic CLK100MHZ ); logic rst_n; logic CLK10HZ; logic [31:0] cnt; logic tx_en_rtl; logic [ 7:0] tx_rtl; logic tx_en_vio; logic [ 7:0] tx_vio; design_1 #()vio( .clk_i(CLK100MHZ), .rst_n(rst_n), .tx_en(tx_en_vio), .tx(tx_vio) ); tx_fifo tx_q( .rst_n(rst_n), .clk_10hz_i(CLK10HZ), .clk_i(CLK100MHZ), .tx_en_i(tx_en_rtl), .tx_i(tx_rtl), .tx_en_o(tx_en_vio), .tx_o(tx_vio) ); clock_gen_for_vio clk_gen( .rst_n(rst_n), .clk_i(CLK100MHZ), .clk_10hz_o(CLK10HZ) ); dammy_rtl dammy( .rst_n(rst_n), .clk_i(CLK100MHZ), .tx_en_rtl(tx_en_rtl), .tx_rtl(tx_rtl) ); endmodule Clocking Wizardありverのトップモジュール (top_usb_uart_tx_with_clkwiz.sv) Clocking Wizardを使うver．Alveoで使う．\n信号名 bit幅[bit] 役割 SYSCLK0_300_P 1 作動クロック信号のP SYSCLK0_300_N 1 作動クロック信号のN 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 module top_usb_uart_tx_with_clkwiz ( input logic SYSCLK0_300_P, input logic SYSCLK0_300_N ); /* ------追加----- */ logic CLK100MHZ; design_2 #()clkwiz( .SYSCLK0_300_P(SYSCLK0_300_P), .SYSCLK0_300_N(SYSCLK0_300_N), .CLK100MHZ(CLK100MHZ), .rst_n(rst_n) ); /* ------------- */ logic rst_n; logic CLK10HZ; logic [31:0] cnt; logic tx_en_rtl; logic [ 7:0] tx_rtl; logic tx_en_vio; logic [ 7:0] tx_vio; design_1 #()vio( .clk_i(CLK100MHZ), .rst_n(rst_n), .tx_en(tx_en_vio), .tx(tx_vio) ); tx_fifo tx_q( .rst_n(rst_n), .clk_10hz_i(CLK10HZ), .clk_i(CLK100MHZ), .tx_en_i(tx_en_rtl), .tx_i(tx_rtl), .tx_en_o(tx_en_vio), .tx_o(tx_vio) ); clock_gen_for_vio clk_gen( .rst_n(rst_n), .clk_i(CLK100MHZ), .clk_10hz_o(CLK10HZ) ); dammy_rtl dammy( .rst_n(rst_n), .clk_i(CLK100MHZ), .tx_en_rtl(tx_en_rtl), .tx_rtl(tx_rtl) ); endmodule 適当なモジュール (dammy_rtl.sv) とりあえずRTLの出力はこんな感じ． まあtx_rtlもtx_en_rtlも出力できりゃあなんでもいいんですよねえ． 信号名 bit幅[bit] 役割 rst_n 1 リセット信号．不論理 clk_i 1 クロック信号 tx_en_rtl 1 tx_dataが有効なら1 tx_data_rtl 8 出力したい文字1個 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 module dammy_rtl ( input logic rst_n, input logic clk_i, output logic tx_en_rtl, output logic [ 7:0] tx_rtl ); logic [31:0] cnt; always_ff @(posedge clk_i) begin if(!rst_n)begin cnt \u0026lt;= 32\u0026#39;b0; tx_en_rtl \u0026lt;= 1\u0026#39;b0; tx_rtl \u0026lt;= 8\u0026#39;h72; end else begin cnt \u0026lt;= (cnt!=32\u0026#39;hFFFFFFFF)?cnt+32\u0026#39;b1:32\u0026#39;b0; if (cnt\u0026gt;=32\u0026#39;d100000 \u0026amp;\u0026amp; cnt\u0026lt;=32\u0026#39;d100020 ) begin tx_en_rtl \u0026lt;= cnt[0]; tx_rtl \u0026lt;= 8\u0026#39;h41 + {7\u0026#39;h0,cnt[0]}; end else begin tx_en_rtl \u0026lt;= 1\u0026#39;b0; tx_rtl \u0026lt;= 8\u0026#39;h43; end end end endmodule Virtual I/Oの速度に合わせたクロック生成モジュール (clock_gen_for_vio.sv) Virtual I/Oは10Hzで値を更新させるので，その速度に合わせたクロック信号を生成するモジュール． ちなみにArtyもAlveoもベースとなるクロック動作周波数は100MHzとしましたわ．\n信号名 bit幅[bit] 役割 rst_n 1 リセット信号．不論理 clk_i 1 ベースとなるクロック信号(100MHz) clk_10hz_o 1 10Hzのクロック信号 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 module clock_gen_for_vio #( parameter MASTER_CLK_HZ = 100000000 )( input logic rst_n, input logic clk_i, output logic clk_10hz_o ); localparam CLK_CNT_MAX = (MASTER_CLK_HZ/10)-1; logic [ 29: 0] cnt; always_ff @(posedge clk_i) begin if (!rst_n)begin cnt \u0026lt;= 30\u0026#39;b0; clk_10hz_o \u0026lt;= 1\u0026#39;b0; end else begin if(cnt==CLK_CNT_MAX)begin cnt \u0026lt;= 30\u0026#39;b0; clk_10hz_o \u0026lt;= ~clk_10hz_o; end else begin cnt \u0026lt;= cnt + 30\u0026#39;b1; end end end endmodule Virtual I/Oの出力データを貯めるFIFO (tx_fifo.sv) 入力は100MHzのクロック信号に合わせて入るものとする． 出力はVIOモジュールに合わせて10Hzです．\n信号名 bit幅[bit] 役割 rst_n 1 リセット信号．不論理 clk_i 1 ベースとなるクロック信号(100MHz) clk_10hz_i 1 10Hzのクロック信号 tx_en_i 1 ダミーのモジュールから入力されたデータが有効か tx_i 8 ダミーのモジュールから入力されたデータ tx_en_o 1 出力するデータが有効か tx_o 8 出力するデータ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 module tx_fifo ( input logic rst_n, input logic clk_i, input logic clk_10hz_i, input logic tx_en_i, input logic [ 7:0] tx_i, output logic tx_en_o, output logic [ 7:0] tx_o ); logic [ 7: 0] tx_ring_queue [ 1023: 0]; logic [ 9: 0] queue_head; logic [ 9: 0] queue_tail; logic empty; assign empty = (queue_head == queue_tail)?1\u0026#39;b1:1\u0026#39;b0; logic full; assign full = ((queue_tail==10\u0026#39;d0) \u0026amp;\u0026amp; ( queue_head== 10\u0026#39;d1023) )?1\u0026#39;b1 :((queue_tail)==(queue_head+10\u0026#39;d1))?1\u0026#39;b1:1\u0026#39;b0; logic clk_10hz_i_old; logic posedge_clk_10hz; assign posedge_clk_10hz = ((clk_10hz_i==1\u0026#39;b1) \u0026amp;\u0026amp; (clk_10hz_i_old==1\u0026#39;b0))?1\u0026#39;b1:1\u0026#39;b0; always_ff @(posedge clk_i) begin if(!rst_n)begin queue_head \u0026lt;= 10\u0026#39;b0; end else if(!full)begin if(tx_en_i)begin tx_ring_queue[queue_head] \u0026lt;= tx_i; queue_head \u0026lt;= (queue_head==10\u0026#39;d1023)?10\u0026#39;b0:(queue_head+10\u0026#39;b1); end end end always_ff @(posedge clk_i) begin if(!rst_n)begin queue_tail \u0026lt;= 10\u0026#39;b0; tx_en_o \u0026lt;= 1\u0026#39;b0; tx_o \u0026lt;= 8\u0026#39;b0; end else if (posedge_clk_10hz) begin if (empty) begin tx_en_o \u0026lt;= 1\u0026#39;b0; tx_o \u0026lt;= 8\u0026#39;b0; end else begin tx_en_o \u0026lt;= 1\u0026#39;b1; tx_o \u0026lt;= tx_ring_queue[queue_tail]; queue_tail \u0026lt;= (queue_tail==10\u0026#39;d1023)?10\u0026#39;b0:(queue_tail+10\u0026#39;b1); end end clk_10hz_i_old \u0026lt;= clk_10hz_i; end endmodule Bitstream生成用のTCLファイル Bitstream生成まで行うTCLファイル（build.tcl） デザインの作成からbitstream生成まで行うTCLファイルbuild.tclはこんな感じ． 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 set projectPath [file normalize [file dirname [file dirname [info script]]]] cd $projectPath # -----defineファイル追加------------- source \u0026#34;$projectPath/tcl/define.tcl\u0026#34; ; # defineファイルを追加 # -----ソースファイル追加------------- set sourceDir \u0026#34;$projectPath/tcl/sources\u0026#34; ; # ソースファイルの置き場所 set source_files [glob -directory $sourceDir -type f \u0026#34;*.tcl\u0026#34;]; # ソースのTCLファイル追加 foreach f $source_files { source $f } # -----元のプロジェクトファイル削除------------- if {[file exists $outputDir] == 1} { ; # プロジェクトファイルがあれば file delete -force $outputDir ; # プロジェクトファイルを削除 } # -----プロジェクトの作成------------- create_project $projectName $outputDir -part $partName ; # プロジェクトファイル作成 update_ip_catalog ; # IPカタログ更新 # -----vio作成------------- set vio_module_name \u0026#34;design_1\u0026#34; set vio_ip_link \u0026#34;xilinx.com:ip:vio:3.0\u0026#34; make_vio_module $vio_module_name $vio_ip_link 100000000 ; # VIOモジュール作成 # -----clkwiz作成------------- set clkwiz_module_name \u0026#34;design_2\u0026#34; set clkwiz_ip_link \u0026#34;xilinx.com:ip:clk_wiz:6.0\u0026#34; if { $need_clkwiz == 1 } { ; # Clocking Wizardが必要なら make_clkwiz_module $clkwiz_module_name $clkwiz_ip_link ; # Clocking Wizardを作成 } # -----RTLファイルの追加------------- add_files $rtl_directory ; # RTLファイル追加 add_files -fileset constrs_1 $constraint_file ; # xdcファイル追加 # -----トップモジュールの設定------------- if { $need_clkwiz == 1 } { ; # Clocking Wizardを使うなら set_property top \u0026#34;top_usb_uart_tx_with_clkwiz\u0026#34; [current_fileset] ; # Clocking Wizardありverのトップモジュールを指定 } else { ; # そうでないなら set_property top \u0026#34;top_usb_uart_tx\u0026#34; [current_fileset] ; # Clocking Wizardなしverのトップモジュールを指定 } # -----ファイルセットの更新------------- update_compile_order -fileset sources_1 ; # 更新 # -----Run Synthesis------------- launch_runs synth_1 -jobs $howManyThread ; # Synthesis実行開始 wait_on_run synth_1 ; # Synthesis実行終了待ち # -----Run Implementation------------- launch_runs impl_1 -jobs $howManyThread ; # Run Implementation開始 wait_on_run impl_1 ; # Run Implementation終了待ち # -----Generate bitstream------------- launch_runs impl_1 -to_step write_bitstream -jobs $howManyThread ; # bitstream生成開始 wait_on_run impl_1 ; # bitstream終了待ち # -----プロジェクトを閉じる------------- close_project 色々定義したTCLファイル(define.tcl) ここを変えればある程度？ボード変えてもいい？？本当か？？？(他のボードで試してないからわからん)\n1 2 3 4 5 6 7 8 9 10 11 12 # -----変数------------- set howManyThread 2 ;# 実行時のスレッド数 set outputDir \u0026#34;$projectPath/output\u0026#34; ;# プロジェクトの出力先 set projectName \u0026#34;vio_show_project\u0026#34; ;# プロジェクト名 set rtl_directory \u0026#34;$projectPath/rtls\u0026#34; ;# RTLファイルのディレクトリ # set constraint_file \u0026#34;$projectPath/consts/Arty-S7-50-Master.xdc\u0026#34; ; # xdcファイルの設定/ set constraint_file \u0026#34;$projectPath/consts/alveo-u250-xdc.xdc\u0026#34; ; # xdcファイルの設定/ # set partName \u0026#34;xc7s50csga324-1\u0026#34; ;# パーツ名 set partName \u0026#34;xcu250-figd2104-2L-e\u0026#34; ;# パーツ名 set hw_device_name \u0026#34;xc7s50_0\u0026#34; ;# デバイス名 set logfile \u0026#34;./output/vio.log\u0026#34; ;# ログファイルの保存先 set need_clkwiz 1 ;# Clocking Wizardが必要なら1に VIOモジュール作成用のTCLファイル(make_vio_design.tcl) これでできるモジュールの入出力は次の通り．\n信号名 bit幅[bit] 役割 rst_n 1 (出力)リセット信号．不論理 clk_i 1 (入力)ベースとなるクロック信号(100MHz) tx_en_i 1 (入力)ダミーのモジュールから入力されたデータが有効か tx_i 8 (入力)ダミーのモジュールから入力されたデータ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 proc make_vio_module { { vio_module_name } { vio_ip_link } { clock_speed_hz } } { create_bd_design $vio_module_name startgroup create_bd_cell -type ip -vlnv $vio_ip_link vio_0 endgroup set_property -dict [list \\ CONFIG.C_NUM_PROBE_IN {2} \\ CONFIG.C_PROBE_IN1_WIDTH {8} \\ ] [get_bd_cells vio_0] create_bd_port -dir I -type clk -freq_hz $clock_speed_hz clk_i create_bd_port -dir O rst_n create_bd_port -dir I tx_en create_bd_port -dir I -from 7 -to 0 tx connect_bd_net [get_bd_ports clk_i] [get_bd_pins vio_0/clk] connect_bd_net [get_bd_ports tx_en] [get_bd_pins vio_0/probe_in0] connect_bd_net [get_bd_ports tx] [get_bd_pins vio_0/probe_in1] connect_bd_net [get_bd_ports rst_n] [get_bd_pins vio_0/probe_out0] save_bd_design } ClockingWizardモジュール作成用のTCLファイル(make_clocking_wizard_design.tcl) これでできるモジュールの入出力は次の通り．\n信号名 bit幅[bit] 役割 SYSCLK0_300_P 1 (入力)作動クロック信号のP SYSCLK0_300_N 1 (入力)作動クロック信号のN rst_n 1 (入力)リセット信号．不論理 CLK100MHZ 1 (出力)ベースとなるクロック信号(100MHz) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 proc make_clkwiz_module { { clkwiz_module_name } { clkwiz_ip_link }} { create_bd_design $clkwiz_module_name create_bd_cell -type ip -vlnv $clkwiz_ip_link clk_wiz_0 set_property -dict [list CONFIG.PRIMITIVE {MMCM} CONFIG.CLK_IN1_BOARD_INTERFACE {default_300mhz_clk0} CONFIG.USE_LOCKED {false} CONFIG.USE_RESET {false} CONFIG.PRIM_SOURCE {Differential_clock_capable_pin} CONFIG.CLKIN1_JITTER_PS {33.330000000000005} CONFIG.CLKOUT1_DRIVES {Buffer} CONFIG.CLKOUT2_DRIVES {Buffer} CONFIG.CLKOUT3_DRIVES {Buffer} CONFIG.CLKOUT4_DRIVES {Buffer} CONFIG.CLKOUT5_DRIVES {Buffer} CONFIG.CLKOUT6_DRIVES {Buffer} CONFIG.CLKOUT7_DRIVES {Buffer} CONFIG.FEEDBACK_SOURCE {FDBK_AUTO} CONFIG.MMCM_BANDWIDTH {OPTIMIZED} CONFIG.MMCM_CLKFBOUT_MULT_F {4.000} CONFIG.MMCM_CLKIN1_PERIOD {3.333} CONFIG.MMCM_CLKIN2_PERIOD {10.0} CONFIG.MMCM_COMPENSATION {AUTO} CONFIG.MMCM_CLKOUT0_DIVIDE_F {12.000} CONFIG.CLKOUT1_JITTER {101.475} CONFIG.CLKOUT1_PHASE_ERROR {77.836}] [get_bd_cells clk_wiz_0] set_property -dict [list \\ CONFIG.CLKOUT1_JITTER {101.475} \\ CONFIG.CLKOUT1_PHASE_ERROR {77.836} \\ CONFIG.CLKOUT1_REQUESTED_OUT_FREQ {100} \\ CONFIG.MMCM_CLKFBOUT_MULT_F {4.000} \\ CONFIG.MMCM_CLKOUT0_DIVIDE_F {12.000} \\ CONFIG.MMCM_DIVCLK_DIVIDE {1} \\ ] [get_bd_cells clk_wiz_0] # -----入力部分の接続-------------------------------- create_bd_port -dir I SYSCLK0_300_N create_bd_port -dir I SYSCLK0_300_P connect_bd_net [get_bd_ports SYSCLK0_300_N] [get_bd_pins clk_wiz_0/clk_in1_n] connect_bd_net [get_bd_ports SYSCLK0_300_P] [get_bd_pins clk_wiz_0/clk_in1_p] # -----出力部分の接続-------------------------------- create_bd_port -dir O CLK100MHZ connect_bd_net [get_bd_ports CLK100MHZ] [get_bd_pins clk_wiz_0/clk_out1] # -----保存-------------------------------- save_bd_design } FPGA上のVIO(出力)を表示させるTCLファイル やりたいこと 作成したbitstreamファイルをFPGAに書き込んだのち，行いたいのは以下の2つ\n最初にrst_nを1→0→1とリセットをかけたい ターミナルやファイルにtx_dataを表示したい 実際のコードshow_vio.tcl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 set projectPath [file normalize [file dirname [file dirname [info script]]]] cd $projectPath ############################################# # defineファイル追加 ############################################# source \u0026#34;$projectPath/tcl/define.tcl\u0026#34; ############################################# # 保存先ファイルの初期化 ############################################# set log [open $logfile w] ;#① 保存先ファイルをopen puts -nonewline $log \u0026#34;\u0026#34; ;#② 中身を削除 close $log ;#③ 保存先ファイルをclose ############################################# # ボーレートの設定 # $delay_time[ms]ごとに計測 ############################################# set_property CORE_REFRESH_RATE_MS 100 [get_hw_vios [get_hw_vios -of_objects [get_hw_devices $hw_device_name] -filter {CELL_NAME=~\u0026#34;vio/vio_0\u0026#34;}]] ############################################# # リセット信号(vio_0_probe_out0)の出力 # 1→0→1 となる ############################################# # 1を出力 set_property OUTPUT_VALUE 1 [get_hw_probes vio/vio_0_probe_out0 -of_objects [get_hw_vios -of_objects [get_hw_devices $hw_device_name] -filter {CELL_NAME=~\u0026#34;vio/vio_0\u0026#34;}]] commit_hw_vio [get_hw_probes {vio/vio_0_probe_out0} -of_objects [get_hw_vios -of_objects [get_hw_devices $hw_device_name] -filter {CELL_NAME=~\u0026#34;vio/vio_0\u0026#34;}]] after 1000 # 0を出力 set_property OUTPUT_VALUE 0 [get_hw_probes vio/vio_0_probe_out0 -of_objects [get_hw_vios -of_objects [get_hw_devices $hw_device_name] -filter {CELL_NAME=~\u0026#34;vio/vio_0\u0026#34;}]] commit_hw_vio [get_hw_probes {vio/vio_0_probe_out0} -of_objects [get_hw_vios -of_objects [get_hw_devices $hw_device_name] -filter {CELL_NAME=~\u0026#34;vio/vio_0\u0026#34;}]] after 1000 # 1を出力 set_property OUTPUT_VALUE 1 [get_hw_probes vio/vio_0_probe_out0 -of_objects [get_hw_vios -of_objects [get_hw_devices $hw_device_name] -filter {CELL_NAME=~\u0026#34;vio/vio_0\u0026#34;}]] commit_hw_vio [get_hw_probes {vio/vio_0_probe_out0} -of_objects [get_hw_vios -of_objects [get_hw_devices $hw_device_name] -filter {CELL_NAME=~\u0026#34;vio/vio_0\u0026#34;}]] ############################################# # 中断するまで表示を繰り返す # Canselを押して中断 ############################################# while {1} { set tx_value_num [get_property INPUT_VALUE [get_hw_probes vio/tx_1] ] ;#RTLから受け取った表示したい文字データ(数値) set tx_value [format %c $tx_value_num] ;#数値を文字に変換 set tx_en_value [get_property INPUT_VALUE [get_hw_probes vio/tx_en_1] ] ;#RTLから受け取った表示したい文字データのenable if {$tx_en_value == 1} then { ;# 表示したい文字があれば puts -nonewline $tx_value ;# TCLコンソールに表示 set log [open $logfile a] ;# 保存先ファイルをopen puts -nonewline $log $tx_value ;# 保存先ファイルに出力 close $log ;# 保存先ファイルをclose } after 100 ;# 100[ms]停止 } 結果 〜bitstream生成 ターミナルで実行しましょ． 1 vivado -mode batch -source tcl/build.tcl 実行後lsするとoutputってディレクトリができますわよ．\nvivadoを立ち上げて書き込み Open Hardware ManagerからOpen TargetのAuto Connectして，Program Deviceで書き込み．\n書き込んだFPGAと通信 Vivadoのtclコンソールで実行しましょ． 1 source tcl/show_vio.tcl その結果．Vivadoはこんな画面になる． 下の方にBDFHJLNPRTと表示されてればOK Canselを押せば停止できますわ． output/vio.logの中身はこんな感じになる． まとめ AlveoU250でシリアル通信ができなかった．しかしまあVirtual I/Oを使って10Hzの速度で出力を文字列で確認できるようにした．\n今後このモジュールを使わなくて済むことを祈っている．\n","permalink":"https://gitefu.github.io/blog/2023/alveou250/how2debug/post1/","tags":["FPGA","Alveo"],"title":"Alveo U250からホストに文字列転送する話"},{"categories":["森の兄貴たち"],"contents":" C101のサークルに無事当選しました！ アイドルマスター シャイニーカラーズのキャラの1人「園田智代子」 と一緒にフィルタ処理を学ぶ本を頒布します．\nまずサークルについて 森の兄貴たち は，ぎてふ(私)，さ〜もんぱん, こじの3人で構成されています．私はスケジュール系の管理や全体の構成サポートを担当しました．メイン著者はこじさんです．次回は多分私がメインかなあ．\n次にこの本について．毎回のことですが，中高生に教えるというコンセプトで書いています． ゆえに初学者にも理解できるかなり簡単な内容にできました．\n頒布情報 当日は既刊含めて3種を頒布します．\n頒布日・場所 - 2日目(2022/12/31(土)) - 西し01a 頒布本 - 新刊：園田智代子と学ぶフィルタ入門 - ¥700 - 既刊：アンデスとUnityする本 - ¥1,000 - 既刊：佐久間まゆとRでデータ解析する本 - ¥1,000 新刊のあらすじ\nある日事務所に集まっていた放課後クライマックスガールズのメンバーは事務所の全部の体重計がバラバラな値を示していることに気がついた。 正しい体重を知るために夏葉は偶然にも学んでいたフィルタ処理を活用できないかと提案する．\n","permalink":"https://gitefu.github.io/blog/2022/c101/notice/","tags":["Comic Market","森の兄貴たち"],"title":"C101で技術本を配布します"},{"categories":["tofunology"],"contents":"　私の所属するモノつくり団体tofunologyはMaker Faire Tokyo 2022に出展します！ MakerFaireTokyo2022は毎年ビッグサイトで開催される国内最大級のモノつくりイベントです． 2019年度から毎年出展し続けており，今年で4年目です．\n私は今回PMとハード-ソフト間システムの担当をしています． 特にPMの役割に関して，私個人がコミケや国内外の発表で忙しいこともあり，結構難航しています． それでも，メンバーの積極的な活動のおかげで，作品がなんとか形になってきました． 今年は14人のメンバーで制作を進めております． 中には今年就職した影響でかなり忙しい状況のメンバーもいますが，彼ら含め全員が開発に力を注いでいます． ぜひ見にきてください！\n作品紹介 新聞紙から文字を切り取り、自動で予告状を作成するマシンです。通常、筆跡を残さないように予告状を作るには、新聞紙から文字を探して切り貼りしていく大変な作業が必要です。そこでこれらの作業を自動化しました。まずOCRを利用して新聞紙から文字を自動で探します。次にその文字を切り取り、ハガキに貼り付けます。印刷ではなく、実際に新聞を切り取ることにこだわったこの予告状マシンをぜひご覧ください！\n出展場所 会場：東京ビッグサイト(東京国際展示場) 西3ホール\n日時：2022/9/3(土) 12:00～17:00 (予定)\n2022/9/4(日) 10:00〜16:00 (予定)\n料金：前売　大人：¥1000　18歳以下：¥500\n当日　大人：¥1000　18歳以下：¥700\n","permalink":"https://gitefu.github.io/blog/2022/mft/notice/","tags":["Maker Faire Tokyo","tofunology"],"title":"Maker Faire Tokyo 2022 に出展します"},{"categories":["森の兄貴たち"],"contents":" C100のサークルに無事当選しました！ アイドルマスター シンデレラガールズのキャラの1人「佐久間まゆ」 と一緒にR言語を使ったデータ解析を行う本を頒布します．\nまずサークルについて 森の兄貴たち は，ぎてふ(私)，さ〜もんぱん, こじの3人で構成されています．私はスケジュール系の管理・シナリオ作成を担当しました．今年は2回目の頒布で今後こそスケジュールを完璧に決めて慌てずに作るぞ！！！といきごんていましたが，当然その通り行かずバタバタしています．今年も印刷所のフルパワーを活用することになりそうです．\n次にこの本について．15,6歳にデータ解析を教えるというコンセプトで書いています． ゆえに初学者にも理解できるかなり簡単な内容にできました．\n頒布情報 当日は既刊含めて2冊を頒布します．\n頒布日・場所 - 1日目(2022/08/13(土)) - 西せ14b 頒布本 - 新刊：佐久間まゆとRでデータ解析する本 - ¥700 - 既刊：アンデスとUnityする本 - ¥1,000 新刊のあらすじ\nプロデューサは事務所で今日も大忙し。 その姿を見た事務所のアイドル「佐久間まゆ」はプロデューサを労う方法を探していた． そこに現れたプログラミングできる系のアイドル「大石泉」はまゆにお弁当を作ることを勧めた．\nしかし，いつもプロデューサは忙しくなると昼食をおにぎりのような軽食で済ませてしまう． そのためまゆはプロデューサがお弁当を食べてくれそうなタイミングを予測できれば...と悩んでいた．\nそこで泉が日頃のプロデューサのデータから忙しさを予想できないかと提案する． データを愛するアイドル「八神マキノ」と計算できる系アイドル(？)「大石泉」とも協力して，佐久間まゆはプロデューサのデータ解析を始めた．\n","permalink":"https://gitefu.github.io/blog/2022/c100/notice/","tags":["Comic Market","森の兄貴たち"],"title":"C100で技術本を配布します"},{"categories":["others"],"contents":"サイトをリニューアルしました． 古い記事を削除し，再度整理して作り直そうかなと思います．\n","permalink":"https://gitefu.github.io/blog/2022/start/notice/","tags":[null],"title":"サイトをリニューアルしました"},{"categories":null,"contents":"\nHello, I’m Gitefu ぎてふ(別名：たなか)は同人サークルで技術書を作ったり，ものつくりサークルでロボット作ったり，色々しています．\n2023現在，とある大学の大学院生をしています． 研究テーマは計算機アーキテクチャ系です．\n所属団体 tofunology 森の兄貴たち Twitter Tweets by tnk_make ","permalink":"https://gitefu.github.io/about/","tags":null,"title":"About"},{"categories":null,"contents":"","permalink":"https://gitefu.github.io/homepage/home-1/","tags":null,"title":"Homepage 1"},{"categories":null,"contents":"　","permalink":"https://gitefu.github.io/search/","tags":null,"title":"Search Result"}]